if [ ! -f ${HOME}/.zgen/zgen.zsh ]
then
    echo 'Cloning zgen...'
    git clone https://github.com/tarjoilija/zgen.git "${HOME}/.zgen"
    if [ "$?" -ne "0" ]; then
        echo "Failed to clone zgen!"
        echo 'Execute the following command get zgen:' > /dev/stderr
        echo '    git clone https://github.com/tarjoilija/zgen.git "${HOME}/.zgen"' > /dev/stderr
        return 1
    fi
fi

_load_plugins() {
    # load zgen
    source "${HOME}/.zgen/zgen.zsh"

    # if the init scipt doesn't exist
    if ! zgen saved; then
        zgen oh-my-zsh plugins/tmux

        # 一些缺省值
        zgen load willghatch/zsh-saneopt

        # # specify plugins here
        # zgen oh-my-zsh

        zgen oh-my-zsh plugins/gitfast
        zgen oh-my-zsh plugins/pip
        zgen oh-my-zsh plugins/python
        zgen oh-my-zsh plugins/safe-paste

        zgen load zlsun/solarized-man
        # zgen load zsh-users/zaw
        zgen load zsh-users/zsh-completions src
        zgen load zsh-users/zsh-autosuggestions

        # mkvenv创建virtualenv，在cd时自动切换
        zgen load MichaelAquilina/zsh-autoswitch-virtualenv

        # 用pip-app安装的每个pip都有自己的virtualenv
        zgen load sharat87/pip-app

        # 如果使用的命令有定义alias，会进行提醒
        zgen load djui/alias-tips

        zgen load s7anley/zsh-geeknote

        zgen load jreese/zsh-titles

        # <ESC><ESC>为当前命令加上sudo
        zgen load hcgraf/zsh-sudo

        zgen load psprint/history-search-multi-word

        # Very cool plugin that generates zsh completion functions for commands
        # if they have getopt-style help text. It doesn't generate them on the fly,
        # you'll have to explicitly generate a completion, but it's still quite cool.
        # 用gencomp命令生成补全文件。
        zgen load RobSis/zsh-completion-generator

        # themes
        zgen oh-my-zsh themes/agnoster

        # generate the init script from plugins above
        zgen save
    fi
}

_load_dotfiles() {
    # Stash your environment variables in ~/.localrc. This means they'll stay out
    # of your main dotfiles repository (which may be public), but you'll have access
    # to them in your scripts.
    [[ -a ~/.localrc ]] && source ~/.localrc
    [[ -a ~/.zshrc.local ]] && source ~/.zshrc.local

    # Append all bin directory to $PATH
    typeset -U bin_dirs
    bin_dirs=($DOTFILES_ROOT/*/bin)
    for d in $bin_dirs
    do
        export PATH="$PATH:$d"
    done
    unset bin_dirs

    # all of our zsh files
    typeset -U config_files
    config_files=($DOTFILES_ROOT/*/(*.zsh|*.sh))

    # load the path files
    for file in ${(M)config_files:#*/path.(sh|zsh)}
    do
        source $file
    done

    # load the env files
    for file in ${(M)config_files:#*/env.(sh|zsh)}
    do
        source $file
    done

    # load everything but the path and completion files
    for file in ${${${config_files:#*/path.(sh|zsh)}:#*/env.(sh|zsh)}:#*/completion.(sh|zsh)}
    do
        source $file
    done

    fpath=($DOTFILES_ROOT/*/zsh-completion(N) $fpath)

    # initialize autocomplete here, otherwise functions won't be loaded
    autoload -U compinit
    compinit

    # load every completion after autocomplete loads
    # for file in ${(M)config_files:#*/completion(|_*).(sh|zsh)}
    # do
    #   source $file
    # done

    unset config_files
}

# DOTFILES_ROOT="$(dirname $(dirname "$(readlink -f "$0")"))"
DOTFILES_ROOT="$HOME/.dotfiles"

# Uncomment the following line to use case-sensitive completion.
CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion. Case
# sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# If current shell doesn't contains zsh, set to zsh
[[ "$SHELL" =~ zsh ]] || export SHELL=$(which zsh)
export ZSH_TMUX_AUTOSTART="true"
export ZSH_TMUX_AUTOQUIT="false"

# 由于启用了tmux插件，在顶层zsh中是不会执行到oh-my-zsh.sh后面的内容的，所以专门source一些需要在顶层载入的内容
if [ "$SHLVL" -eq 1 ]
then
    # 在顶层SHELL中恢复base16的配色
    [ -e "$DOTFILES_ROOT/base-16/env.sh" ] && source "$DOTFILES_ROOT/base-16/env.sh"

    # Fix problem that SSH_AUTH_SOCK not updated in tmux
    if [ ! -z "$SSH_AUTH_SOCK" -a -e "$SSH_AUTH_SOCK" -a "$SSH_AUTH_SOCK" != "$HOME/.ssh/ssh_auth_sock" -a -d "$HOME/.ssh" ] ; then
        unlink "$HOME/.ssh/ssh_auth_sock" 2>/dev/null
        ln -s "$SSH_AUTH_SOCK" "$HOME/.ssh/ssh_auth_sock"
        export SSH_AUTH_SOCK="$HOME/.ssh/ssh_auth_sock"
    fi
fi

_load_plugins
_load_dotfiles

