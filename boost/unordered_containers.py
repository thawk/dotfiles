# encoding: utf-8

# Boost Software License - Version 1.0 - August 17th, 2003

# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:

# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from .utils import *
import itertools


class BoostUnorderedCommon:
    """Common base for boost unordered containers"""
    def __init__(self, val):
        self.val = val

    @staticmethod
    def nodes(start_node):
        """Generator iterating over all nodes in unordered container"""
        node_ptr = start_node.address
        while True:
            next_ptr = node_ptr.dereference()['next_']
            if not next_ptr or next_ptr == node_ptr:
                return
            node_ptr = next_ptr
            yield node_ptr.dereference()

    def stored_items(self):
        """Generator iterating over all items stored in container"""
        table = self.val['table_']
        buckets = table['buckets_']
        if not buckets:
            return

        value_type = get_inner_type(self.val.type, 'value_type')

        # In case of unusual allocators (such as boost::interprocess::allocator) there is an extra node in the beginning
        bucket_allocator_type = table['allocators_'].type.template_argument(0)
        bucket_type = bucket_allocator_type.template_argument(0)
        extra_node = get_basic_type(bucket_type).name != 'boost::unordered::detail::ptr_bucket'

        node_allocator_type = table['allocators_'].type.template_argument(1)
        node_type = node_allocator_type.template_argument(0)

        bucket_count = table['bucket_count_']
        start_node = buckets[bucket_count]

        for node in itertools.islice(self.nodes(start_node), 1 if extra_node else 0, None):
            node_data = reinterpret_cast(node, node_type)['value_base_']['data_']
            stored_value = reinterpret_cast(node_data, value_type)
            yield stored_value

    def size(self):
        table = self.val['table_']
        buckets = table['buckets_']
        return table['size_'] if buckets else 0


@add_printer
class BoostUnorderedMapPrinter(BoostUnorderedCommon):
    """Pretty Printer for boost::unordered_map and boost::unordered_multimap (Boost.Unordered)"""
    printer_name = 'boost::unordered_map'
    min_supported_version = (1, 58, 0)
    max_supported_version = last_supported_boost_version
    template_name = ['boost::unordered::unordered_map', 'boost::unordered::unordered_multimap']

    def __init__(self, val):
        BoostUnorderedCommon.__init__(self, val)

    def to_string(self):
        template_name = self.val.template_name
        container_type = self.val.type.strip_typedefs()
        key_type = container_type.template_argument(0)
        value_type = container_type.template_argument(1)
        return '{}<{}, {}> size = {}'.format(template_name, key_type, value_type, self.size())

    def children(self):
        for item_number, item in enumerate(self.stored_items()):
            yield 'key[{}]'.format(item_number), item['first']
            yield 'value[{}]'.format(item_number), item['second']

    def display_hint(self):
        return 'map'


@add_printer
class BoostUnorderedSetPrinter(BoostUnorderedCommon):
    """Pretty Printer for boost::unordered_map and boost::unordered_multimap (Boost.Unordered)"""
    printer_name = 'boost::unordered_set'
    min_supported_version = (1, 58, 0)
    max_supported_version = last_supported_boost_version
    template_name = ['boost::unordered::unordered_set', 'boost::unordered::unordered_multiset']

    def __init__(self, val):
        BoostUnorderedCommon.__init__(self, val)

    def to_string(self):
        template_name = self.val.template_name
        container_type = self.val.type.strip_typedefs()
        value_type = container_type.template_argument(0)
        return '{}<{}> size = {}'.format(template_name, value_type, self.size())

    def children(self):
        for item_number, item in enumerate(self.stored_items()):
            yield '[{}]'.format(item_number), item

    def display_hint(self):
        return 'array'


@add_printer
class BoostUnorderedIterator:
    """Pretty Printer for unordered container iterators (Boost.Unordered)"""
    printer_name = 'boost::unordered::iterator'
    min_supported_version = (1, 58, 0)
    max_supported_version = last_supported_boost_version
    template_name = ['boost::unordered::iterator_detail::iterator', 'boost::unordered::iterator_detail::c_iterator']

    def __init__(self, value):
        self.val = value

    def to_string(self):
        return None if self.val['node_'] else 'uninitialized'

    def children(self):
        node_pointer = self.val['node_']
        if node_pointer:
            value_type = get_inner_type(self.val.type, 'value_type')

            node = node_pointer.dereference()
            node_data = node['value_base_']['data_']
            stored_value = reinterpret_cast(node_data, value_type)
            return [('value', stored_value)]
        return []
