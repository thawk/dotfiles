#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
import os
import sys
import click
import subprocess
import functools
import pandas as pd
import re
from operator import itemgetter, attrgetter
from collections import namedtuple

VERSION = u'20221031'

class Context(object):
    def __init__(self):
        self.quiet = False
        self.verbose = False
        self.dry_run = False

pass_context = click.make_pass_decorator(Context, ensure=True)

Tag = namedtuple('Tag', ['name', 'value'])

def get_cmd_executor(func, dry_run):
    def executor(cmd):
        if dry_run:
            logging.info(f'  {cmd}...')
        else:
            logging.debug(f'  {cmd}...')
            result = subprocess.run(cmd)
            result.check_returncode()

    return lambda file, tags, *args, **kwargs: func(executor, file, tags, *args, **kwargs)


def tag_flac(executor, file, tags, remove_all_tags=False):
    cmd = ['metaflac']

    if remove_all_tags:
        cmd += ['--remove-all-tags']
    else:
        cmd += list(set([
            f'--remove-tag={tag.name}'
            for tag in tags
        ]))

    cmd += [
        f'--set-tag={tag.name}={tag.value}'
        for tag in tags
        if tag.value is not None
    ]

    cmd.append(file)

    executor(cmd)


def tags_from_params(**kwargs):
    TAG_MAP = {
        'GENRE': 'genre',
        'ARTIST': 'composer',
        'COMPOSER': 'composer',
        'ALBUM': 'album',
        'PERFORMER': 'performer',
        'YEAR': 'year',
        'TITLE': 'title',
    }

    tags = list()
    for tag, key in TAG_MAP.items():
        val = kwargs.get(key, None)
        if val is not None:
            tags.append(Tag(tag, val))

    comment = kwargs.get('comment', None)
    performer = kwargs.get('performer', None)

    if performer:
        # performer作为COMMENT的第一项，comment附加到后面
        if comment:
            comment = f'{performer}, {comment}'
        else:
            comment = performer

    if comment:
        tags.append(Tag('COMMENT', comment))

    renumber = kwargs.get('renumber', 0)
    if renumber and renumber > 0:
        tags.append(Tag('TRACKNUMBER', None))
        tags.append(Tag('TRACKTOTAL', None))
        tags.append(Tag('TOTALTRACKS', None))

    return renumber, tags


def tags_from_flac(file):
    RE_LINE = re.compile(r'^(?P<name>[^=]+)=(?P<value>.*)')

    cmd = ['metaflac']

    cmd += ['--export-tags-to=-']

    cmd.append(file)

    result = subprocess.run(cmd, capture_output=True, text=True)
    result.check_returncode()

    tags = []
    tag_name = None
    tag_value = None

    for line in result.stdout.split('\n'):
        m = RE_LINE.match(line)
        if m:
            if tag_name is not None:
                tags.append(Tag(tag_name, tag_value))

            tag_name = m.group('name')
            tag_value = m.group('value')
        elif tag_name is not None:
            tag_value = tag_value + '\n' + line
    else:
        if tag_name is not None:
            tags.append(Tag(tag_name, tag_value))

    return tags

def tags_from_dict(d):
    """Get tags from dict like or Series.
    """
    tags = list()

    for n, v in d.items():
        tags.append(Tag(n, v))

    return tags

def tags_to_dict(tags):
    """Convert tags to dict, keep first tag if duplicated.
    """
    result = dict()
    for tag in tags:
        if tag.name not in result:
            result[tag.name] = tag.value

    return result


def init_common_params(func):
    """Used to inject common params to sub-command
    """

    @click.option('--quiet', '-q', is_flag=True, default=False, help="Quiet mode.")
    @click.option('--verbose', '-v', is_flag=True, default=False, help="Verbose mode.")
    @click.option('--dry-run', '-n', is_flag=True, help='Show command, not run.')
    @pass_context
    @functools.wraps(func)
    def wrapper(context, *args, **kwargs):
        context.quiet = kwargs['quiet']
        context.verbose = kwargs['verbose']
        context.dry_run = kwargs['dry_run']

        del kwargs['quiet']
        del kwargs['verbose']
        del kwargs['dry_run']

        return func(context, *args, **kwargs)

    return wrapper


def common_params(func):

    @init_common_params
    @functools.wraps(func)
    def wrapper(context, *args, **kwargs):
        setup_logger(quiet=context.quiet, verbose=context.verbose)

        return func(context, *args, **kwargs)

    return wrapper


def setup_logger(quiet=False, verbose=False):
    """日志初始化
    Args:
        args (Dict[string, string]): 命令行参数
    """
    log_format = u'%(asctime)s %(levelname)s %(message)s'

    if quiet:
        logging.basicConfig(level=logging.WARNING, format=log_format)
    elif verbose:
        logging.basicConfig(level=logging.DEBUG, format=log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=log_format)


@click.group()
@click.version_option(version=VERSION)
@init_common_params
def cli(
    context,
):
    pass


@cli.command(help='Tag files with specified tags')
@click.option('--genre', '-g', type=str, help='Set GENRE tag')
@click.option('--composer', '-c', type=str, help='Set COMPOSER/ARTIST tag')
@click.option('--album', '-a', type=str, help='Set ALBUM tag')
@click.option('--performer', '-p', type=str, help='Set PERFORMER tag')
@click.option('--year', '-y', type=int, help='Set YEAR tag')
@click.option('--comment', '-C', type=str, help='Set COMMENT tag')
@click.option('--renumber', '-r', type=int, is_flag=False, flag_value=1, help='Renumber track, started from specified number')
@click.option('--title', '-t', type=str, help='Set TITLE tag')
@click.argument('files', nargs=-1, type=click.Path(exists=True))
@common_params
def tag(
        context,
        files,
        **kwargs):

    renumber, tags = tags_from_params(**kwargs)

    if not renumber and not tags:
        logging.info(f'Nothing to do.')
        return

    logging.info(f'Tagging {len(files)} files...')
    for i, f in enumerate(files):
        if renumber:
            file_tags = tags + [Tag('TRACKNUMBER', renumber+i)]
        else:
            file_tags = tags

        get_cmd_executor(tag_flac, dry_run=context.dry_run)(f, file_tags)

    logging.info(f'Done.')


@cli.command(help='Show existed tags')
@click.option('--output', '-o', required=False, type=click.File('wb'))
@click.argument('files', nargs=-1, type=click.Path(exists=True))
@common_params
def export_tags(
        context,
        output,
        files):

    logging.info(f'Exporting tags for {len(files)} files...')

    file_tags = list()
    for i, f in enumerate(files):
        logging.debug(f'  Handling {f}...')

        tags = tags_from_flac(f)
        d = tags_to_dict(tags)
        file_tag = {'filename':f}
        file_tag.update(d)
        file_tags.append(file_tag)

        logging.info(f'  {len(d)}/{len(tags)} tags for "{f}"')
        for tag in tags:
            logging.debug(f'    {tag.name} = {tag.value}')

    df = pd.DataFrame(file_tags)

    if output is not None:
        df.to_csv(output, index=False)
        logging.info(f'Tags exported to "{output.name}"')


@cli.command(help='Import tags from file')
@click.option('--clear', '-c', is_flag=True, help='Clear unused tags')
@click.option('--rename', '-r', is_flag=True, help='rename music file')
@click.argument('tags_file', nargs=1, type=click.File('rb'))
@common_params
def import_tags(
        context,
        clear,
        rename,
        tags_file):

    logging.info(f'Importing tags for {tags_file.name} files...')

    df = pd.read_csv(tags_file)

    tag_names = [ c for c in df.columns if c != 'filename' ]
    logging.info(f'  Total {df.shape[0]} files, {len(tag_names)} tags: {",".join(tag_names)}')

    for f, row in df.set_index('filename').iterrows():
        get_cmd_executor(tag_flac, dry_run=context.dry_run)(
            f, tags_from_dict(row), remove_all_tags=clear)

if __name__ == '__main__':
    cli()
