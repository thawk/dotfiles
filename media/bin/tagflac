#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
import os
import sys
import click
import subprocess
import shutil
import functools
import pandas as pd
import re
from pathlib import Path
from operator import itemgetter, attrgetter
from collections import namedtuple, defaultdict

VERSION = u'20221031'

class Context(object):
    def __init__(self):
        self.quiet = False
        self.verbose = False
        self.dry_run = False

pass_context = click.make_pass_decorator(Context, ensure=True)


class Tags(object):
    album = 'ALBUM'
    artist = 'ARTIST'
    composer = 'COMPOSER'
    genre = 'GENRE'
    performer = 'PERFORMER'
    title = 'TITLE'
    year = 'YEAR'
    comment = 'COMMENT'
    track_number = 'TRACKNUMBER'
    track_total = 'TRACKTOTAL'
    total_tracks = 'TOTALTRACKS'


def get_cmd_executor(func, dry_run):
    def executor(cmd):
        if dry_run:
            logging.info(f'  {cmd}...')
        else:
            logging.debug(f'  {cmd}...')
            result = subprocess.run(cmd)
            result.check_returncode()

    return lambda file, tags, *args, **kwargs: func(executor, file, tags, *args, **kwargs)


def tag_flac(executor, file, tags, remove_all_tags=False):
    cmd = ['metaflac']

    if remove_all_tags:
        cmd += ['--remove-all-tags']
    else:
        cmd += list(set([
            f'--remove-tag={tag.name}'
            for tag in tags.keys()
        ]))

    cmd += [
        f'--set-tag={tag}={val}'
        for tag, vals in tags.items()
        if vals is not None
        for val in vals
    ]

    cmd.append(file)

    executor(cmd)


def tags_from_params(**kwargs):
    TAG_MAP = {
        Tags.genre: 'genre',
        Tags.artist: 'composer',
        Tags.composer: 'composer',
        Tags.album: 'album',
        Tags.performer: 'performer',
        Tags.year: 'year',
        Tags.title: 'title',
    }

    tags = defaultdict(list)
    for tag, key in TAG_MAP.items():
        val = kwargs.get(key, None)
        if val is not None:
            tags[tag].append(val)

    comment = kwargs.get('comment', None)
    performer = kwargs.get('performer', None)

    if performer:
        # performer作为COMMENT的第一项，comment附加到后面
        if comment:
            comment = f'{performer}, {comment}'
        else:
            comment = performer

    if comment:
        tags[Tags.comment].append(comment)

    renumber = kwargs.get('renumber', 0)
    if renumber and renumber > 0:
        tags[Tags.track_number].clear()
        tags[Tags.track_total].clear()
        tags[Tags.total_tracks].clear()

    return renumber, tags


def tags_from_flac(file):
    RE_LINE = re.compile(r'^(?P<name>[^=]+)=(?P<value>.*)')

    cmd = ['metaflac']

    cmd += ['--export-tags-to=-']

    cmd.append(file)

    result = subprocess.run(cmd, capture_output=True, text=True)
    result.check_returncode()

    tags = defaultdict(list)
    tag_name = None
    tag_value = None

    for line in result.stdout.split('\n'):
        m = RE_LINE.match(line)
        if m:
            if tag_name is not None:
                tags[tag_name].append(tag_value)

            tag_name = m.group('name')
            tag_value = m.group('value')
        elif tag_name is not None:
            tag_value = tag_value + '\n' + line
    else:
        if tag_name is not None:
            tags[tag_name].append(tag_value)

    return tags

def tags_from_dict(d):
    """Get tags from dict like or Series.
    """
    tags = defaultdict(list)

    for n, v in d.items():
        tags[n].append(v)

    return tags

def tags_to_dict(tags):
    """Convert tags to dict, keep first tag if duplicated.
    """
    result = dict()
    for tag, vals in tags.items():
        if len(vals) > 0:
            result[tag] = vals[0]

    return result


def init_common_params(func):
    """Used to inject common params to sub-command
    """

    @click.option('--quiet', '-q', is_flag=True, default=False, help="Quiet mode.")
    @click.option('--verbose', '-v', is_flag=True, default=False, help="Verbose mode.")
    @click.option('--dry-run', '-n', is_flag=True, help='Show command, not run.')
    @pass_context
    @functools.wraps(func)
    def wrapper(context, *args, **kwargs):
        context.quiet = kwargs['quiet']
        context.verbose = kwargs['verbose']
        context.dry_run = kwargs['dry_run']

        del kwargs['quiet']
        del kwargs['verbose']
        del kwargs['dry_run']

        return func(context, *args, **kwargs)

    return wrapper


def common_params(func):

    @init_common_params
    @functools.wraps(func)
    def wrapper(context, *args, **kwargs):
        setup_logger(quiet=context.quiet, verbose=context.verbose)

        return func(context, *args, **kwargs)

    return wrapper


def setup_logger(quiet=False, verbose=False):
    """日志初始化
    Args:
        args (Dict[string, string]): 命令行参数
    """
    log_format = u'%(asctime)s %(levelname)s %(message)s'

    if quiet:
        logging.basicConfig(level=logging.WARNING, format=log_format)
    elif verbose:
        logging.basicConfig(level=logging.DEBUG, format=log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=log_format)


@click.group()
@click.version_option(version=VERSION)
@init_common_params
def cli(
    context,
):
    pass


@cli.command(help='Tag files with specified tags')
@click.option('--genre', '-g', type=str, help='Set GENRE tag')
@click.option('--composer', '-c', type=str, help='Set COMPOSER/ARTIST tag')
@click.option('--album', '-a', type=str, help='Set ALBUM tag')
@click.option('--performer', '-p', type=str, help='Set PERFORMER tag')
@click.option('--year', '-y', type=int, help='Set YEAR tag')
@click.option('--comment', '-C', type=str, help='Set COMMENT tag')
@click.option('--renumber', '-r', type=int, is_flag=False, flag_value=1, help='Renumber track, started from specified number')
@click.option('--title', '-t', type=str, help='Set TITLE tag')
@click.argument('files', nargs=-1, type=click.Path(exists=True))
@common_params
def tag(
        context,
        files,
        **kwargs):

    renumber, tags = tags_from_params(**kwargs)

    if not renumber and not tags:
        logging.info(f'Nothing to do.')
        return

    logging.info(f'Tagging {len(files)} files...')
    for i, f in enumerate(files):
        if renumber:
            file_tags = tags.copy()
            file_tags['TRACKNUMBER'] = [renumber+i]
        else:
            file_tags = tags

        get_cmd_executor(tag_flac, dry_run=context.dry_run)(f, file_tags)

    logging.info(f'Done.')


@cli.command(help='Show existed tags')
@click.option('--output', '-o', required=False, type=click.File('wb'))
@click.argument('files', nargs=-1, type=click.Path(exists=True))
@common_params
def export_tags(
        context,
        output,
        files):

    logging.info(f'Exporting tags for {len(files)} files...')

    file_tags = list()
    for i, f in enumerate(files):
        logging.debug(f'  Handling {f}...')

        tags = tags_from_flac(f)
        d = tags_to_dict(tags)
        file_tag = {'filename':f}
        file_tag.update(d)
        file_tags.append(file_tag)

        logging.info(f'  {len(d)}/{len(tags)} tags for "{f}"')
        for tag, vals in tags.items():
            for val in vals:
                if output is None:
                    logging.info(f'    {tag} = {val}')
                else:
                    logging.debug(f'    {tag} = {val}')

    df = pd.DataFrame(file_tags)

    if output is not None:
        df.to_csv(output, index=False)
        logging.info(f'Tags exported to "{output.name}"')

def safe_path(path_elem):
    replacements = {
        ':': '：',
        '/': '／',
        '<': '＜',
        '>': '＞',
        '?': '？',
        '*': '＊',
        '"': '＂',
        '\\': '＼',
    }

    for f, t in replacements.items():
        path_elem = path_elem.replace(f, t)

    return path_elem

def path_from_tags(root, file_ext, tags):
    """Get file path frm tags.

    Args:
        root: root directory
        file_ext: .flac/.mp3 ...
        tags: tags of file

    Return:
        file path, include file name
    """
    path = Path(root)
    path /= safe_path(tags[Tags.artist][0])

    if Tags.genre in tags:
        path /= safe_path(tags[Tags.genre][0])

    path /= safe_path(tags[Tags.album][0])

    if Tags.track_number in tags:
        name = f'{tags[Tags.track_number][0]:02} {tags[Tags.title][0]}'
    else:
        name = tags[Tags.title][0]

    path /= safe_path(name) + file_ext
    
    return path


@cli.command(help='Import tags from file')
@click.option('--clear', '-c', is_flag=True, help='Clear unused tags')
@click.option('--outdir', '-o', required=False, type=click.Path(writable=True, dir_okay=True, file_okay=False), help='Output directory')
@click.argument('tags_file', nargs=1, type=click.File('rb'))
@common_params
def import_tags(
        context,
        clear,
        outdir,
        tags_file):

    logging.info(f'Importing tags for {tags_file.name} files...')

    df = pd.read_csv(tags_file)

    tag_names = [ c for c in df.columns if c != 'filename' ]
    logging.info(f'  Total {df.shape[0]} files, {len(tag_names)} tags: {",".join(tag_names)}')

    i = 0
    for f, row in df.set_index('filename').iterrows():
        i += 1
        tags = tags_from_dict(row)

        if outdir:
            src = Path(f)
            dest_file = path_from_tags(outdir, src.suffix, tags)
            
            if not context.dry_run:
                dest_file.parent.mkdir(parents=True, exist_ok=True)
                shutil.copyfile(src, dest_file, follow_symlinks=True)
            else:
                logging.info(f'  copy "{src}" to "{dest_file}"...')
        else:
            dest_file = f

        if not context.dry_run:
            logging.info(f'  {i:02}: "{dest_file}"...')

        get_cmd_executor(tag_flac, dry_run=context.dry_run)(
            dest_file, tags_from_dict(row), remove_all_tags=clear)

if __name__ == '__main__':
    cli()
